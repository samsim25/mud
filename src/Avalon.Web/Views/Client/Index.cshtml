@{
    Layout = null;
}
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Avalon Web Client</title>
    <style>
        body {
            font-family: Consolas, monospace;
            background: #222;
            color: #eee;
            margin: 0;
            padding: 0;
        }
        #terminal {
            max-width: 1280px;
            max-height: 960px;
            width: 100vw;
            height: 90vh;
            background: #111;
            color: #eee;
            font-size: 20px;
            overflow-y: auto;
            padding: 1em;
            margin: 2em auto 0 auto;
            box-sizing: border-box;
            word-break: break-word;
            white-space: pre-wrap;
            border-radius: 8px;
            box-shadow: 0 2px 16px #000a;
        }
        #input {
            width: 100vw;
            font-size: 20px;
            padding: 1em;
            border: none;
            background: #333;
            color: #eee;
        }
        #fontSize {
            margin: 1em;
        }
        /* ANSI color and style classes */
        .ansi-black { color: #555; }
        .ansi-red { color: #c00; }
        .ansi-green { color: #0c0; }
        .ansi-yellow { color: #cc0; }
        .ansi-blue { color: #08f; }
        .ansi-magenta { color: #c0c; }
        .ansi-cyan { color: #0cc; }
        .ansi-white { color: #eee; }
        .ansi-bright-black { color: #888; }
        .ansi-bright-red { color: #f55; }
        .ansi-bright-green { color: #5f5; }
        .ansi-bright-yellow { color: #ff5; }
        .ansi-bright-blue { color: #5af; }
        .ansi-bright-magenta { color: #f5f; }
        .ansi-bright-cyan { color: #5ff; }
        .ansi-bright-white { color: #fff; }
        .ansi-bold { font-weight: bold; }
        .ansi-underline { text-decoration: underline; }
        .ansi-inverse { background: #eee; color: #111; }
    </style>
</head>
<body>
    <div id="connection" style="max-width:1280px;margin:0 auto;">
        <label>Host:</label>
        <input type="text" id="host" value="anguish.org" />
        <label>Port:</label>
        <input type="number" id="port" value="2222" />
        <button id="connectBtn">Connect</button>
        <span id="status">Disconnected</span>
    </div>
    <div id="terminal"></div>
    <input id="input" type="text" placeholder="Type your command..." autocomplete="off" style="max-width:1280px;display:block;margin:0 auto;" />
    <div id="fontSize" style="max-width:1280px;margin:0 auto;">
        Font Size:
        <input type="range" min="8" max="32" value="20" id="fontSlider" />
        <span id="fontValue">20</span>px
    </div>
    <script src="/ansi-format.js"></script>
    <script>
        const terminal = document.getElementById('terminal');
        const input = document.getElementById('input');
        const fontSlider = document.getElementById('fontSlider');
        const fontValue = document.getElementById('fontValue');
        const connectBtn = document.getElementById('connectBtn');
        const hostInput = document.getElementById('host');
        const portInput = document.getElementById('port');
        const status = document.getElementById('status');

        let connected = false;
        let socket = null;

        fontSlider.addEventListener('input', function() {
            terminal.style.fontSize = fontSlider.value + 'px';
            input.style.fontSize = fontSlider.value + 'px';
            fontValue.textContent = fontSlider.value;
        });

        let clearOnNextInput = false;
        // Whether new incoming lines should auto-scroll to the bottom.
        let isAutoScrollEnabled = true;

        // Command history
        const history = [];
        let historyIndex = -1; // -1 = not browsing history
        let tempInput = ''; // store current edited value when starting to browse history

        // Small threshold in pixels to consider "at bottom" due to subpixel/layout differences.
        const SCROLL_BOTTOM_THRESHOLD = 4;

        // Monitor user scrolling to freeze/unfreeze auto-scroll.
        terminal.addEventListener('scroll', function() {
            const atBottom = (terminal.scrollTop + terminal.clientHeight) >= (terminal.scrollHeight - SCROLL_BOTTOM_THRESHOLD);
            if (atBottom) {
                // User is at the bottom — re-enable auto-scroll so new content will follow.
                isAutoScrollEnabled = true;
            } else {
                // User scrolled up — freeze auto-scroll so new content doesn't jump the view.
                isAutoScrollEnabled = false;
            }
        });
        input.addEventListener('keydown', function(e) {
            if (clearOnNextInput) {
                // If the user types a printable character, only clear the input
                // when the caret is at the end (they intend to start a new command).
                if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
                    const selStart = input.selectionStart;
                    const selEnd = input.selectionEnd;
                    if (selStart === selEnd && selEnd === input.value.length) {
                        input.value = '';
                    }
                    clearOnNextInput = false;
                } else if (e.key === 'Backspace' || e.key === 'Delete' || e.key.startsWith('Arrow') || e.key === 'Home' || e.key === 'End' || e.key === 'PageUp' || e.key === 'PageDown') {
                    // User is navigating or editing existing text — cancel the clear flag and don't wipe the value.
                    clearOnNextInput = false;
                } else {
                    // For other keys (modifiers, etc.) just cancel the flag.
                    clearOnNextInput = false;
                }
            }

            if (e.key === 'Enter') {
                const cmd = input.value;
                // User submitted a command — re-enable auto-scroll and jump to bottom so they see immediate response.
                isAutoScrollEnabled = true;
                terminal.innerHTML += '<div>&gt; ' + (window.ansiToHtml ? window.ansiToHtml(cmd) : cmd) + '</div>';
                terminal.scrollTop = terminal.scrollHeight;
                if (connected && socket) {
                    socket.send(cmd + '\r\n');
                }
                // Mark to clear input on next keypress only
                clearOnNextInput = true;
                // Add to history (ignore empty commands)
                if (cmd && cmd.trim().length > 0) {
                    history.push(cmd);
                }
                // reset browsing state
                historyIndex = -1;
                tempInput = '';
            }

            // History navigation: Up/Down arrows
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                // Prevent cursor movement in the input
                e.preventDefault();
                if (history.length === 0) return;

                if (historyIndex === -1) {
                    // start browsing: save current value
                    tempInput = input.value;
                    historyIndex = history.length - 1;
                } else if (e.key === 'ArrowUp') {
                    // move older
                    if (historyIndex > 0) historyIndex--;
                } else if (e.key === 'ArrowDown') {
                    // move newer
                    if (historyIndex < history.length - 1) historyIndex++;
                    else {
                        // beyond newest -> restore temp and stop browsing
                        historyIndex = -1;
                        input.value = tempInput;
                        return;
                    }
                }

                if (historyIndex !== -1) {
                    input.value = history[historyIndex];
                    // Move caret to end
                    input.selectionStart = input.selectionEnd = input.value.length;
                }
            }
        });

        connectBtn.addEventListener('click', function() {
            if (connected && socket) {
                socket.close();
                status.textContent = 'Disconnected';
                connectBtn.textContent = 'Connect';
                connected = false;
                return;
            }
            const host = hostInput.value;
            const port = portInput.value;
            // Use backend websocket endpoint
            const wsProtocol = location.protocol === 'https:' ? 'wss' : 'ws';
            socket = new WebSocket(`${wsProtocol}://${location.host}/ws?host=${host}&port=${port}`);
            status.textContent = 'Connecting...';
            socket.onopen = function() {
                status.textContent = 'Connected';
                connectBtn.textContent = 'Disconnect';
                connected = true;
            };
            socket.onmessage = function(event) {
                let data = event.data;
                // Attempt to decode if it's a Blob or ArrayBuffer
                if (data instanceof Blob) {
                    const reader = new FileReader();
                    reader.onload = function() {
                        renderTerminalOutput(reader.result);
                    };
                    reader.readAsText(data, 'utf-8');
                    return;
                }
                renderTerminalOutput(data);
            };

            function renderTerminalOutput(data) {
                // Normalize data to string
                let clean = typeof data === 'string' ? data : String(data);
                // Remove common replacement characters
                clean = clean.replace(/�/g, '');
                // If ansiToHtml is available, use it (handles escaping and spans)
                if (window.ansiToHtml) {
                    terminal.innerHTML += '<div>' + window.ansiToHtml(clean) + '</div>';
                } else {
                    // Fallback: strip ANSI escape sequences and escape HTML
                    const stripped = clean.replace(/\x1B\[[0-9;]*m/g, '');
                    const esc = stripped.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    terminal.innerHTML += '<div>' + esc + '</div>';
                }

                // Only auto-scroll if the user hasn't scrolled up to view history.
                if (isAutoScrollEnabled) {
                    terminal.scrollTop = terminal.scrollHeight;
                }
            }
            socket.onclose = function() {
                status.textContent = 'Disconnected';
                connectBtn.textContent = 'Connect';
                connected = false;
            };
            socket.onerror = function() {
                status.textContent = 'Error';
                connectBtn.textContent = 'Connect';
                connected = false;
            };
        });
    </script>
</body>
</html>
